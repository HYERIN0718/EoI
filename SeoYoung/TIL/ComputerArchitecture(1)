-- 컴퓨터 산술과 논리 연산 --

01. ALU의 구성요소 (Arithmetic Logic Unit; 산술 논리 연산 장치)
// 산술연산, 논리 연산을 하기 때문에 연산을 하기 위해 수에 대한 개념을 알고 있어야 한다.
// 컴퓨터가 수를 어떻게 표현하고 기억하고 있는지.
  1) 산술 연산 장치 
  2) 논리 연산 쟝치 
  3) 시프트 레지스터 : 비트들을 좌측 혹은 우측으로 이동시키는 기능을 가진 레지스터
  4) 보수기(complementer) : 2진 데이터를 2의 보수로 변환(음수화) 
  5) 상태 레지스터 : 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터
  -> 일종의 하드웨어 모듈
  
  
02. 정수의 표현
  [ 0,1,부호,소수점 ]으로 수 표현
  부호 없는 정수는 양수를 의미한다.
  
  ** 소수점의 경우, 
  2^(-1)=0.5 , 2^(-2)=0.25 , 2^(-3)=0.125... 순으로 간다.
  
  2진수를 3자리씩 읽으면 8진수, 4자리씩 읽으면 16진수 
  10110001101011.111100100 -> 8진수  : 010/110/001/101/011.111/100/100  (맨 앞에 0 붙여줌)
                           -> 16진수 : 0010/1100/0110/1011.1111/0010    (맨 앞에 00 붙여줌, 맨 뒤에 0 버림)
                           
  ** 음수의 경우 표현 방법이 3가지 있다.
  1) 부호화-크기 표현 : 맨 좌측 비트는 부호 비트, 나머지(n-1)개의 비트들은 수의 크기를 나타냄.
     ex) + 9 = 0 0001001
         - 9 = 1 0001001
  2) 1의 보수 표현 : 모든 비트들을 반전 
     ex) + 9 = 0 0001001
         - 9 = 1 1110110 (1의 보수)
         - 9 = 1 1110111 (2의 보수)
  3) 2의 보수 표현 : 모든 비트들을 반전하고, 결과값에 1을 더한다.
  => 결과적으로 2의 보수 표현 사용 중.
  
  1의 보수는 [ -2^(n-1) ~ 2^(n-1) ] 표현 가능
  2의 보수는 [ -2^(n)   ~ 2^(n-1) ] 표현 가능
      ex) 8비트 2진수로 표현할 수 있는 10진수의 범위는 (2^7=128)
          1의 보수 : -127~127 
          2의 보수 : -128~127
  1의 보수는 +0(00000000)과 -0(11111111)을 나누어 표현하지만 2의 보수는 둘 다 00000000으로 표현.(-0이 존재하지 않음)
  
  ** 2의 보수->10진수 변환
  
  ** 보수를 사용하는 이유 : 뺄셈을 하기 위해서. 가산기 하나만으로 덧셈과 뺄셈 가능하기 때문에 2의 보수 사용
  
  ** 비트 확장 : 데이터를 더 많은 비트의 레지스터에 저장하거나 더 긴 데이터와 연산을 수행하기 위함
  -> 0은 앞을 0으로 다 채움, 1로 시작하면 1을 앞으로 쭉 당기고 나머지 확장 비트를 0으로 채움.
  -> 또 하나의 방법은 확장되는 상위 비트를 부호 비트로 같은 값으로 확장할 수도 있음. 0을 계속 붙여주거나, 1을 계속 붙여주거나.
      
---------------------

01. 논리 연산
  기본적인 논리 연산 꼭 기억하기. 모양도. AND, OR, XOR, NOT
  
  ** 다수 함수 : Input이 세 개가 들어오는 경우. 경우의 수 2^3=8가지.
             : 입력 신호들 중에 1의 신호가 0의 신호보다 많으면 출력은 1, 반대면 0
  ** 논리식, 논리 회로도, 진리표
  
  ** 논리 연산을 위한 하드웨어 모듈
   > 입력 비트들은 모두 논리 게이트를 통과한다.
   > 선택 신호들에 의해서 멀티플렉서의 네 입력들 중의 하나를 출력. 
     선택 신호들 (S1,S2)은 [0.0]=AND, [0,1]=OR, [1,0]=XOR, [1,1]=NOT을 의미한다.
     
  ** N-비트 논리 연산 장치 
  하나의 논리 모듈에 대해 두 개의 input, 하나의 output. 각각에 대해 선택 신호. 8비트가 들어오면 4비트가 출력됨
  
  ** 선택적-세트(selective-set) 연산 / 선택적-보수(selective-complement) 연산
  > 선택적 세트 연산 : B 레지스터의 비트들 중에서 1로 세트된 비트들과 같은 위치에 있는 A 레지스터의 비트들을 1로 세트 
    -> OR 연산 이용
  > 선택적 보수 연산 : B 레지스터의 비트들 중에서 1로 세트된 비트들에 대응되는 A 레지스터의 비트들을 보수로 변환
    -> XOR 연산 이용
  ** 마스크 연산 : B 레지스터의 비트들 증에서 값이 0인 비트들과 같은 위치에 있는 A 레지스터의 비트들을 0으로 바꾸는 연산. clear 용도
    -> AND 연산 이용
  ** 삽입 연산 : 새로운 비트 값들을 특정 위치에 삽입
    -> AND 연산 이용 후, OR 연산 이용
  ** 비교 연산
    -> XOR 연산 
  
02. 시프트 연산 : 레지스터 내의 데이터 비트들을 왼쪽 혹은 오른쪽으로 한 칸씩 이동
  1) 좌측 시프트
    > 최하위 비트 0이 들어오고, 최상위 비트는 버림.
  2) 우측 시프트 
    > 최상위 비트 0이 들어오고, 최하위 비트는 버림.

  ** 순환 시프트(circular shift) 
    > 순환 좌측 시프트
    > 순환 우측 시프트
  
  ** 직렬 데이터 전송(serial data transfer)
  : 시프트 연산을 데이터 비트 수만큼 연속적으로 수행함으로써 두 레지스터들 사이에 한 개의 선을 통하여 전체 데이터를 이동하는 동작
  : A레지스터는 순환하면서(4번) B레지스터로 우측 시프트(4번). B 레지스터에 순차적으로 들어가고, A 레지스터는 순환하면서 원래 데이터를 유지. 그럼 복제가 된 건가???????
  
  // 지금까지는 논리적인 리프트였다면,
  ** 산술 시프트(arithmetic shift)
  : 수(number)를 나타내는 데이터에 대한 시프트. 부호 비트는 그대로 유지시키고, 수의 크기를 나타내는 비트들만 시프트.
    > 산술적 좌측-시프트 : 원래의 값의 2배    | 부호 그대로 유지. 하나.
    > 산술적 우측-시프트 : 원래의 값의 1/2배  | 부호 2개. 
    예제 3-19(동영상29분) 이해가 안가. 초기 상태 값이 왜 -2지? 그 후 시프트 연산은 이해가 가는데. 2의 보수? 1110->0001->+1하면 0010->2? 다음문제는 안그런데? 2의 보수로 초기상태안하잖아.
    
  ** C 플래그를 포함한 시프트 연산
    > SHLC (shift left with carry)
    > SHRC (shift right with carry)
  
  
---------------------

01. 정수의 산술 연산

  ** 2의 보수로 표현된 수들의 덧셈 : 두 수를 더하고, 민약 올림수가 발생하면 버린다.
    ex) (-3) + (+3) = 1101 + 0101 = 1 0000. -> 1을 버리면 0000. 즉 0이다.
        // 3은 0011. 1의 보수로 바꾸면 1100. +1하면 1101. => -3은 1101
    ex) (-6) + (+2) = 1010 + 0010 = 1100 -> -4
        // 6은 0110. 1의 보수로 바꾸면 1001. +1하면 1010. => -6은 1010
        // 1100. 1이 맨 앞이니까 일단 -. 1의 보수 취하면 0011. +1하면 0100 = 4. => 1100은 -4
        // 애초에 2의 보수로 표현되었으니까 1100도 2의 보수이고, 다시 10진수로 바꿔준다.
        
  ** 병렬 가산기 (parallel adder) : 덧셈을 수행하는 하드웨어 모듈
  : 비트 수만큼의 전가산기(Full Adder;FA)로 구성됨.
  : 덧셈 연산 결과들에 따라 해당 조건 플래그들을 세트. 
   > C : 올림수    ; 올림이 있다면 플래그 값이 1
   > S : 부호
   > Z : 0(zero) ; 0이라면 플래그 값이 1
   > V : 오버플로우
  // 상태 레지스터에는 여러가지 조건 플래그들이 있다.
  
  ** 4-비트 병렬 가산기와 상태 비트 제어 회로
  
  ** 덧셈 오버플로우 : 덧셈의 결과가 그 범위를 초과하여 결과값이 틀리게 되는 상태.
    > 검출 방법 : 두 올림수(carry)들 간의 XOR 이용
    ex)
    
  ** 덧셈과 뺄셈 겸용 하드웨어의 블록 구성도 
  
  ** 4-비트 병렬 가감산기 // 참고로만 알아두기
  
  ** 뺼셈 오버플로우 : 뺼셈 결과가 그 범위를 초과하여 결과값이 틀리게 되는 상태.
    > 검출 방법 : 덧셈과 동일. 두 올림수 간의 XOR.
    ex)
  
  
  ** 정수
  1) 부호 없는 정수의 곱셈(양수)
    > 각 비트에 대하여 부분 적(partial product) 계산.
    > 각 계산 결과를 모두 더해 최종 결과 도출.
  
  2) 2의 보수들 간의 곱셈(양수+음수) <Booth 알고리즘>
    > 부호 없는 정수 승산기의 하드웨어에 다음 부분을 추가
    > M 레지스터와 병렬 가산기 사이에 보수기 추가
    > Q 레지스터의 우측에 1-비트 레지스터를 추가하고 , 출력을 Q0와 함께 제어 회로로 입력.
  
  ** 부호 없는 정수 승산기의 하드웨어 구성도 
  ** 곱셈이 수행되는 과정에서의 레지스터 내용들 ===== 다시보기. 이해 안갔어.
  
  ** Booth 알고리즘 흐름도
  
  ** 나눗셈
  
  
  


